// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: seller.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSeller = `-- name: CreateSeller :one
INSERT INTO sellers (
  username, full_name, email, password, mobile_number,
  store_name, gst_number, drug_license_number,
  seller_type, store_address
) VALUES (
  $1, $2, $3, $4, $5,
  $6, $7, $8,
  $9, $10
) RETURNING username, full_name, email, password, mobile_number, store_name, gst_number, drug_license_number, seller_type, store_address, password_changed_at, created_at
`

type CreateSellerParams struct {
	Username          string `json:"username"`
	FullName          string `json:"full_name"`
	Email             string `json:"email"`
	Password          string `json:"password"`
	MobileNumber      string `json:"mobile_number"`
	StoreName         string `json:"store_name"`
	GstNumber         string `json:"gst_number"`
	DrugLicenseNumber string `json:"drug_license_number"`
	SellerType        string `json:"seller_type"`
	StoreAddress      string `json:"store_address"`
}

func (q *Queries) CreateSeller(ctx context.Context, arg CreateSellerParams) (Seller, error) {
	row := q.db.QueryRow(ctx, createSeller,
		arg.Username,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.MobileNumber,
		arg.StoreName,
		arg.GstNumber,
		arg.DrugLicenseNumber,
		arg.SellerType,
		arg.StoreAddress,
	)
	var i Seller
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.MobileNumber,
		&i.StoreName,
		&i.GstNumber,
		&i.DrugLicenseNumber,
		&i.SellerType,
		&i.StoreAddress,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSeller = `-- name: DeleteSeller :one
DELETE FROM sellers WHERE username = $1
RETURNING username
`

func (q *Queries) DeleteSeller(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, deleteSeller, username)
	err := row.Scan(&username)
	return username, err
}

const getSellerByName = `-- name: GetSellerByName :one
SELECT username, full_name, email, password, mobile_number, store_name, gst_number, drug_license_number, seller_type, store_address, password_changed_at, created_at FROM sellers WHERE username = $1
`

func (q *Queries) GetSellerByName(ctx context.Context, username string) (Seller, error) {
	row := q.db.QueryRow(ctx, getSellerByName, username)
	var i Seller
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.MobileNumber,
		&i.StoreName,
		&i.GstNumber,
		&i.DrugLicenseNumber,
		&i.SellerType,
		&i.StoreAddress,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listSellersByStoreName = `-- name: ListSellersByStoreName :many
SELECT username, full_name, email, password, mobile_number, store_name, gst_number, drug_license_number, seller_type, store_address, password_changed_at, created_at FROM sellers
WHERE store_name ILIKE '%' || $1 || '%'
ORDER BY store_name
LIMIT $3 OFFSET $2
`

type ListSellersByStoreNameParams struct {
	StoreName pgtype.Text `json:"store_name"`
	Offset    int32       `json:"offset"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) ListSellersByStoreName(ctx context.Context, arg ListSellersByStoreNameParams) ([]Seller, error) {
	rows, err := q.db.Query(ctx, listSellersByStoreName, arg.StoreName, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seller{}
	for rows.Next() {
		var i Seller
		if err := rows.Scan(
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.Password,
			&i.MobileNumber,
			&i.StoreName,
			&i.GstNumber,
			&i.DrugLicenseNumber,
			&i.SellerType,
			&i.StoreAddress,
			&i.PasswordChangedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSeller = `-- name: UpdateSeller :one
UPDATE sellers SET
  full_name = COALESCE($1, full_name),
  email = COALESCE($2, email),
  password = COALESCE($3, password),
  mobile_number = COALESCE($4, mobile_number),
  store_name = COALESCE($5, store_name),
  gst_number = COALESCE($6, gst_number),
  drug_license_number = COALESCE($7, drug_license_number),
  seller_type = COALESCE($8, seller_type),
  store_address = COALESCE($9, store_address),
  password_changed_at = COALESCE($10, password_changed_at)
WHERE username = $11
RETURNING username, full_name, email, password, mobile_number, store_name, gst_number, drug_license_number, seller_type, store_address, password_changed_at, created_at
`

type UpdateSellerParams struct {
	FullName          pgtype.Text      `json:"full_name"`
	Email             pgtype.Text      `json:"email"`
	Password          pgtype.Text      `json:"password"`
	MobileNumber      pgtype.Text      `json:"mobile_number"`
	StoreName         pgtype.Text      `json:"store_name"`
	GstNumber         pgtype.Text      `json:"gst_number"`
	DrugLicenseNumber pgtype.Text      `json:"drug_license_number"`
	SellerType        pgtype.Text      `json:"seller_type"`
	StoreAddress      pgtype.Text      `json:"store_address"`
	PasswordChangedAt pgtype.Timestamp `json:"password_changed_at"`
	Username          string           `json:"username"`
}

func (q *Queries) UpdateSeller(ctx context.Context, arg UpdateSellerParams) (Seller, error) {
	row := q.db.QueryRow(ctx, updateSeller,
		arg.FullName,
		arg.Email,
		arg.Password,
		arg.MobileNumber,
		arg.StoreName,
		arg.GstNumber,
		arg.DrugLicenseNumber,
		arg.SellerType,
		arg.StoreAddress,
		arg.PasswordChangedAt,
		arg.Username,
	)
	var i Seller
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.MobileNumber,
		&i.StoreName,
		&i.GstNumber,
		&i.DrugLicenseNumber,
		&i.SellerType,
		&i.StoreAddress,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}
